<TracedFile path="Lean4Example.lean" md5="76e30bc32bea91589646a017d853600e">
  <FileNode start="(1, 1)" end="(43, 13)">
    <ModuleHeaderNode start="(1, 1)" end="(3, 34)">
      <NullNode/>
      <NullNode start="(1, 1)" end="(3, 34)">
        <ModuleImportNode start="(1, 1)" end="(1, 22)" module="Mathlib.Tactic" path=".lake/packages/mathlib/Mathlib/Tactic.lean">
          <AtomNode start="(1, 1)" end="(1, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(1, 8)" end="(1, 22)" leading="" trailing="&#10;-- imports all the Lean tactics&#10;" raw_val="Mathlib.Tactic" val="Mathlib.Tactic"/>
          <NullNode/>
        </ModuleImportNode>
        <ModuleImportNode start="(3, 1)" end="(3, 34)" module="Mathlib.Order.Filter.Basic" path=".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean">
          <AtomNode start="(3, 1)" end="(3, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(3, 8)" end="(3, 34)" leading="" trailing="&#10;&#10;" raw_val="Mathlib.Order.Filter.Basic" val="Mathlib.Order.Filter.Basic"/>
          <NullNode/>
        </ModuleImportNode>
      </NullNode>
    </ModuleHeaderNode>
    <CommandOpenNode start="(5, 1)" end="(5, 9)">
      <AtomNode start="(5, 1)" end="(5, 5)" leading="" trailing=" " val="open"/>
      <OtherNode start="(5, 6)" end="(5, 9)" kind="Lean.Parser.Command.openSimple">
        <NullNode start="(5, 6)" end="(5, 9)">
          <IdentNode start="(5, 6)" end="(5, 9)" leading="" trailing="&#10;&#10;" raw_val="Nat" val="Nat"/>
        </NullNode>
      </OtherNode>
    </CommandOpenNode>
    <OtherNode start="(7, 1)" end="(7, 20)" kind="Lean.Parser.Command.variable">
      <AtomNode start="(7, 1)" end="(7, 9)" leading="" trailing=" " val="variable"/>
      <NullNode start="(7, 10)" end="(7, 20)">
        <OtherNode start="(7, 10)" end="(7, 20)" kind="Lean.Parser.Term.implicitBinder">
          <AtomNode start="(7, 10)" end="(7, 11)" leading="" trailing="" val="{"/>
          <NullNode start="(7, 11)" end="(7, 12)">
            <IdentNode start="(7, 11)" end="(7, 12)" leading="" trailing=" " raw_val="α" val="α"/>
          </NullNode>
          <NullNode start="(7, 13)" end="(7, 19)">
            <AtomNode start="(7, 13)" end="(7, 14)" leading="" trailing=" " val=":"/>
            <OtherNode start="(7, 15)" end="(7, 19)" kind="Lean.Parser.Term.type">
              <AtomNode start="(7, 15)" end="(7, 19)" leading="" trailing="" val="Type"/>
              <NullNode/>
            </OtherNode>
          </NullNode>
          <AtomNode start="(7, 19)" end="(7, 20)" leading="" trailing="&#10;" val="}"/>
        </OtherNode>
      </NullNode>
    </OtherNode>
    <OtherNode start="(8, 1)" end="(8, 24)" kind="Lean.Parser.Command.variable">
      <AtomNode start="(8, 1)" end="(8, 9)" leading="" trailing=" " val="variable"/>
      <NullNode start="(8, 10)" end="(8, 24)">
        <TermExplicitbinderNode start="(8, 10)" end="(8, 24)">
          <AtomNode start="(8, 10)" end="(8, 11)" leading="" trailing="" val="("/>
          <NullNode start="(8, 11)" end="(8, 16)">
            <IdentNode start="(8, 11)" end="(8, 12)" leading="" trailing=" " raw_val="p" val="p"/>
            <IdentNode start="(8, 13)" end="(8, 14)" leading="" trailing=" " raw_val="q" val="q"/>
            <IdentNode start="(8, 15)" end="(8, 16)" leading="" trailing=" " raw_val="r" val="r"/>
          </NullNode>
          <NullNode start="(8, 17)" end="(8, 23)">
            <AtomNode start="(8, 17)" end="(8, 18)" leading="" trailing=" " val=":"/>
            <OtherNode start="(8, 19)" end="(8, 23)" kind="Lean.Parser.Term.prop">
              <AtomNode start="(8, 19)" end="(8, 23)" leading="" trailing="" val="Prop"/>
            </OtherNode>
          </NullNode>
          <NullNode/>
          <AtomNode start="(8, 23)" end="(8, 24)" leading="" trailing="&#10;&#10;" val=")"/>
        </TermExplicitbinderNode>
      </NullNode>
    </OtherNode>
    <CommandOpenNode start="(10, 1)" end="(10, 16)">
      <AtomNode start="(10, 1)" end="(10, 5)" leading="" trailing=" " val="open"/>
      <OtherNode start="(10, 6)" end="(10, 16)" kind="Lean.Parser.Command.openSimple">
        <NullNode start="(10, 6)" end="(10, 16)">
          <IdentNode start="(10, 6)" end="(10, 12)" leading="" trailing=" " raw_val="Filter" val="Filter"/>
          <IdentNode start="(10, 13)" end="(10, 16)" leading="" trailing="&#10;&#10;" raw_val="Set" val="Set"/>
        </NullNode>
      </OtherNode>
    </CommandOpenNode>
    <CommandOpenNode start="(12, 1)" end="(12, 19)">
      <AtomNode start="(12, 1)" end="(12, 5)" leading="" trailing=" " val="open"/>
      <OtherNode start="(12, 6)" end="(12, 19)" kind="Lean.Parser.Command.openScoped">
        <AtomNode start="(12, 6)" end="(12, 12)" leading="" trailing=" " val="scoped"/>
        <NullNode start="(12, 13)" end="(12, 19)">
          <IdentNode start="(12, 13)" end="(12, 19)" leading="" trailing="&#10;&#10;" raw_val="Filter" val="Filter"/>
        </NullNode>
      </OtherNode>
    </CommandOpenNode>
    <CommandDeclarationNode start="(14, 1)" end="(16, 41)" name="hello_world" full_name="hello_world">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(14, 1)" end="(16, 41)" name="hello_world" full_name="hello_world" _is_private_decl="False">
        <AtomNode start="(14, 1)" end="(14, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(14, 9)" end="(14, 20)">
          <IdentNode start="(14, 9)" end="(14, 20)" leading="" trailing=" " raw_val="hello_world" val="hello_world"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(14, 21)" end="(15, 26)">
          <NullNode start="(14, 21)" end="(14, 34)">
            <TermExplicitbinderNode start="(14, 21)" end="(14, 34)">
              <AtomNode start="(14, 21)" end="(14, 22)" leading="" trailing="" val="("/>
              <NullNode start="(14, 22)" end="(14, 27)">
                <IdentNode start="(14, 22)" end="(14, 23)" leading="" trailing=" " raw_val="a" val="a"/>
                <IdentNode start="(14, 24)" end="(14, 25)" leading="" trailing=" " raw_val="b" val="b"/>
                <IdentNode start="(14, 26)" end="(14, 27)" leading="" trailing=" " raw_val="c" val="c"/>
              </NullNode>
              <NullNode start="(14, 28)" end="(14, 33)">
                <AtomNode start="(14, 28)" end="(14, 29)" leading="" trailing=" " val=":"/>
                <IdentNode start="(14, 30)" end="(14, 33)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path=".lake/packages/lean4/src/lean/Init/Prelude.lean" def_start="(1073, 11)" def_end="(1073, 14)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(14, 33)" end="(14, 34)" leading="" trailing="&#10;  " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(15, 3)" end="(15, 26)">
            <AtomNode start="(15, 3)" end="(15, 4)" leading="" trailing=" " val=":"/>
            <OtherNode start="(15, 5)" end="(15, 26)" kind="«term_=_»">
              <OtherNode start="(15, 5)" end="(15, 14)" kind="«term_+_»">
                <OtherNode start="(15, 5)" end="(15, 10)" kind="«term_+_»">
                  <IdentNode start="(15, 5)" end="(15, 6)" leading="" trailing=" " raw_val="a" val="a"/>
                  <AtomNode start="(15, 7)" end="(15, 8)" leading="" trailing=" " val="+"/>
                  <IdentNode start="(15, 9)" end="(15, 10)" leading="" trailing=" " raw_val="b" val="b"/>
                </OtherNode>
                <AtomNode start="(15, 11)" end="(15, 12)" leading="" trailing=" " val="+"/>
                <IdentNode start="(15, 13)" end="(15, 14)" leading="" trailing=" " raw_val="c" val="c"/>
              </OtherNode>
              <AtomNode start="(15, 15)" end="(15, 16)" leading="" trailing=" " val="="/>
              <OtherNode start="(15, 17)" end="(15, 26)" kind="«term_+_»">
                <OtherNode start="(15, 17)" end="(15, 22)" kind="«term_+_»">
                  <IdentNode start="(15, 17)" end="(15, 18)" leading="" trailing=" " raw_val="a" val="a"/>
                  <AtomNode start="(15, 19)" end="(15, 20)" leading="" trailing=" " val="+"/>
                  <IdentNode start="(15, 21)" end="(15, 22)" leading="" trailing=" " raw_val="c" val="c"/>
                </OtherNode>
                <AtomNode start="(15, 23)" end="(15, 24)" leading="" trailing=" " val="+"/>
                <IdentNode start="(15, 25)" end="(15, 26)" leading="" trailing=" " raw_val="b" val="b"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(15, 27)" end="(16, 41)">
          <AtomNode start="(15, 27)" end="(15, 29)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(15, 30)" end="(16, 41)">
            <AtomNode start="(15, 30)" end="(15, 32)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(16, 3)" end="(16, 41)">
              <TacticTacticseq1IndentedNode start="(16, 3)" end="(16, 41)">
                <NullNode start="(16, 3)" end="(16, 41)">
                  <OtherNode start="(16, 3)" end="(16, 41)" kind="Lean.Parser.Tactic.rwSeq" state_before="a b c : ℕ&#10;⊢ a + b + c = a + c + b" state_after="no goals" tactic="rw [add_assoc, add_comm b, ←add_assoc]">
                    <AtomNode start="(16, 3)" end="(16, 5)" leading="" trailing=" " val="rw"/>
                    <NullNode/>
                    <OtherNode start="(16, 6)" end="(16, 41)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(16, 6)" end="(16, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(16, 7)" end="(16, 40)">
                        <OtherNode start="(16, 7)" end="(16, 16)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(16, 7)" end="(16, 16)" leading="" trailing="" raw_val="add_assoc" val="add_assoc" full_name="add_assoc" mod_name="Mathlib.Algebra.Group.Defs" def_path=".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean" def_start="(262, 3)" def_end="(262, 14)"/>
                        </OtherNode>
                        <AtomNode start="(16, 16)" end="(16, 17)" leading="" trailing=" " val=","/>
                        <OtherNode start="(16, 18)" end="(16, 28)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <OtherNode start="(16, 18)" end="(16, 28)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(16, 18)" end="(16, 26)" leading="" trailing=" " raw_val="add_comm" val="add_comm" full_name="add_comm" mod_name="Mathlib.Algebra.Group.Defs" def_path=".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean" def_start="(297, 3)" def_end="(297, 14)"/>
                            <NullNode start="(16, 27)" end="(16, 28)">
                              <IdentNode start="(16, 27)" end="(16, 28)" leading="" trailing="" raw_val="b" val="b"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                        <AtomNode start="(16, 28)" end="(16, 29)" leading="" trailing=" " val=","/>
                        <OtherNode start="(16, 30)" end="(16, 40)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode start="(16, 30)" end="(16, 31)">
                            <OtherNode start="(16, 30)" end="(16, 31)" kind="patternIgnore">
                              <OtherNode start="(16, 30)" end="(16, 31)" kind="token.«← »">
                                <AtomNode start="(16, 30)" end="(16, 31)" leading="" trailing="" val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <IdentNode start="(16, 31)" end="(16, 40)" leading="" trailing="" raw_val="add_assoc" val="add_assoc" full_name="add_assoc" mod_name="Mathlib.Algebra.Group.Defs" def_path=".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean" def_start="(262, 3)" def_end="(262, 14)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(16, 40)" end="(16, 41)" leading="" trailing="&#10;&#10;" val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(18, 1)" end="(18, 53)" name="foo" full_name="foo">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(18, 1)" end="(18, 53)" name="foo" full_name="foo" _is_private_decl="False">
        <AtomNode start="(18, 1)" end="(18, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(18, 9)" end="(18, 12)">
          <IdentNode start="(18, 9)" end="(18, 12)" leading="" trailing=" " raw_val="foo" val="foo"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(18, 13)" end="(18, 43)">
          <NullNode start="(18, 13)" end="(18, 22)">
            <TermExplicitbinderNode start="(18, 13)" end="(18, 22)">
              <AtomNode start="(18, 13)" end="(18, 14)" leading="" trailing="" val="("/>
              <NullNode start="(18, 14)" end="(18, 15)">
                <IdentNode start="(18, 14)" end="(18, 15)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(18, 16)" end="(18, 21)">
                <AtomNode start="(18, 16)" end="(18, 17)" leading="" trailing=" " val=":"/>
                <IdentNode start="(18, 18)" end="(18, 21)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path=".lake/packages/lean4/src/lean/Init/Prelude.lean" def_start="(1073, 11)" def_end="(1073, 14)"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(18, 21)" end="(18, 22)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(18, 23)" end="(18, 43)">
            <AtomNode start="(18, 23)" end="(18, 24)" leading="" trailing=" " val=":"/>
            <OtherNode start="(18, 25)" end="(18, 43)" kind="«term_=_»">
              <OtherNode start="(18, 25)" end="(18, 30)" kind="«term_+_»">
                <IdentNode start="(18, 25)" end="(18, 26)" leading="" trailing=" " raw_val="a" val="a"/>
                <AtomNode start="(18, 27)" end="(18, 28)" leading="" trailing=" " val="+"/>
                <OtherNode start="(18, 29)" end="(18, 30)" kind="num">
                  <AtomNode start="(18, 29)" end="(18, 30)" leading="" trailing=" " val="1"/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(18, 31)" end="(18, 32)" leading="" trailing=" " val="="/>
              <OtherNode start="(18, 33)" end="(18, 43)" kind="Lean.Parser.Term.app">
                <IdentNode start="(18, 33)" end="(18, 41)" leading="" trailing=" " raw_val="Nat.succ" val="Nat.succ" full_name="Nat.succ" mod_name="Init.Prelude" def_path=".lake/packages/lean4/src/lean/Init/Prelude.lean" def_start="(1083, 5)" def_end="(1083, 9)"/>
                <NullNode start="(18, 42)" end="(18, 43)">
                  <IdentNode start="(18, 42)" end="(18, 43)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(18, 44)" end="(18, 53)">
          <AtomNode start="(18, 44)" end="(18, 46)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(18, 47)" end="(18, 53)">
            <AtomNode start="(18, 47)" end="(18, 49)" leading="" trailing=" " val="by"/>
            <TacticTacticseqNode start="(18, 50)" end="(18, 53)">
              <TacticTacticseq1IndentedNode start="(18, 50)" end="(18, 53)">
                <NullNode start="(18, 50)" end="(18, 53)">
                  <OtherNode start="(18, 50)" end="(18, 53)" kind="Lean.Parser.Tactic.tacticRfl" state_before="a : ℕ&#10;⊢ a + 1 = a.succ" state_after="no goals" tactic="rfl">
                    <AtomNode start="(18, 50)" end="(18, 53)" leading="" trailing="&#10;&#10;" val="rfl"/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(20, 1)" end="(31, 30)" name="test1" full_name="test1">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(20, 1)" end="(31, 30)" name="test1" full_name="test1" _is_private_decl="False">
        <AtomNode start="(20, 1)" end="(20, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(20, 9)" end="(20, 14)">
          <IdentNode start="(20, 9)" end="(20, 14)" leading="" trailing=" " raw_val="test1" val="test1"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(20, 15)" end="(20, 48)">
          <NullNode start="(20, 15)" end="(20, 28)">
            <TermExplicitbinderNode start="(20, 15)" end="(20, 28)">
              <AtomNode start="(20, 15)" end="(20, 16)" leading="" trailing="" val="("/>
              <NullNode start="(20, 16)" end="(20, 19)">
                <IdentNode start="(20, 16)" end="(20, 17)" leading="" trailing=" " raw_val="S" val="S"/>
                <IdentNode start="(20, 18)" end="(20, 19)" leading="" trailing=" " raw_val="T" val="T"/>
              </NullNode>
              <NullNode start="(20, 20)" end="(20, 27)">
                <AtomNode start="(20, 20)" end="(20, 21)" leading="" trailing=" " val=":"/>
                <OtherNode start="(20, 22)" end="(20, 27)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(20, 22)" end="(20, 25)" leading="" trailing=" " raw_val="Set" val="Set" full_name="Set" mod_name="Mathlib.Data.Set.Defs" def_path=".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean" def_start="(44, 5)" def_end="(44, 8)"/>
                  <NullNode start="(20, 26)" end="(20, 27)">
                    <IdentNode start="(20, 26)" end="(20, 27)" leading="" trailing="" raw_val="α" val="α"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(20, 27)" end="(20, 28)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(20, 29)" end="(20, 48)">
            <AtomNode start="(20, 29)" end="(20, 30)" leading="" trailing=" " val=":"/>
            <OtherNode start="(20, 31)" end="(20, 48)" kind="«term_↔_»">
              <OtherNode start="(20, 31)" end="(20, 40)" kind="«term_≤_»">
                <OtherNode start="(20, 31)" end="(20, 34)" kind="Lean.Parser.Term.app">
                  <OtherNode start="(20, 31)" end="(20, 32)" kind="Filter.term𝓟">
                    <AtomNode start="(20, 31)" end="(20, 32)" leading="" trailing=" " val="𝓟"/>
                  </OtherNode>
                  <NullNode start="(20, 33)" end="(20, 34)">
                    <IdentNode start="(20, 33)" end="(20, 34)" leading="" trailing=" " raw_val="S" val="S"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(20, 35)" end="(20, 36)" leading="" trailing=" " val="≤"/>
                <OtherNode start="(20, 37)" end="(20, 40)" kind="Lean.Parser.Term.app">
                  <OtherNode start="(20, 37)" end="(20, 38)" kind="Filter.term𝓟">
                    <AtomNode start="(20, 37)" end="(20, 38)" leading="" trailing=" " val="𝓟"/>
                  </OtherNode>
                  <NullNode start="(20, 39)" end="(20, 40)">
                    <IdentNode start="(20, 39)" end="(20, 40)" leading="" trailing=" " raw_val="T" val="T"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(20, 41)" end="(20, 42)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(20, 43)" end="(20, 48)" kind="«term_⊆_»">
                <IdentNode start="(20, 43)" end="(20, 44)" leading="" trailing=" " raw_val="S" val="S"/>
                <AtomNode start="(20, 45)" end="(20, 46)" leading="" trailing=" " val="⊆"/>
                <IdentNode start="(20, 47)" end="(20, 48)" leading="" trailing=" " raw_val="T" val="T"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(20, 49)" end="(31, 30)">
          <AtomNode start="(20, 49)" end="(20, 51)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(20, 52)" end="(31, 30)">
            <AtomNode start="(20, 52)" end="(20, 54)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(21, 3)" end="(31, 30)">
              <TacticTacticseq1IndentedNode start="(21, 3)" end="(31, 30)">
                <NullNode start="(21, 3)" end="(31, 30)">
                  <OtherNode start="(21, 3)" end="(21, 14)" kind="Lean.Parser.Tactic.constructor" state_before="α : Type&#10;S T : Set α&#10;⊢ 𝓟 S ≤ 𝓟 T ↔ S ⊆ T" state_after="case mp&#10;α : Type&#10;S T : Set α&#10;⊢ 𝓟 S ≤ 𝓟 T → S ⊆ T&#10;&#10;case mpr&#10;α : Type&#10;S T : Set α&#10;⊢ S ⊆ T → 𝓟 S ≤ 𝓟 T" tactic="constructor">
                    <AtomNode start="(21, 3)" end="(21, 14)" leading="" trailing="&#10;  " val="constructor"/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(22, 3)" end="(26, 29)" kind="Lean.cdot" state_before="case mp&#10;α : Type&#10;S T : Set α&#10;⊢ 𝓟 S ≤ 𝓟 T → S ⊆ T&#10;&#10;case mpr&#10;α : Type&#10;S T : Set α&#10;⊢ S ⊆ T → 𝓟 S ≤ 𝓟 T" state_after="case mpr&#10;α : Type&#10;S T : Set α&#10;⊢ S ⊆ T → 𝓟 S ≤ 𝓟 T" tactic="· intro h&#10;  rw [le_def] at h&#10;  have hT : T ∈ 𝓟 T := mem_principal_self T&#10;  specialize h T hT&#10;  rwa [mem_principal] at h">
                    <OtherNode start="(22, 3)" end="(22, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(22, 3)" end="(22, 4)" kind="patternIgnore">
                        <OtherNode start="(22, 3)" end="(22, 4)" kind="token.«· »">
                          <AtomNode start="(22, 3)" end="(22, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(22, 5)" end="(26, 29)">
                      <TacticTacticseq1IndentedNode start="(22, 5)" end="(26, 29)">
                        <NullNode start="(22, 5)" end="(26, 29)">
                          <OtherNode start="(22, 5)" end="(22, 12)" kind="Lean.Parser.Tactic.intro" state_before="case mp&#10;α : Type&#10;S T : Set α&#10;⊢ 𝓟 S ≤ 𝓟 T → S ⊆ T" state_after="case mp&#10;α : Type&#10;S T : Set α&#10;h : 𝓟 S ≤ 𝓟 T&#10;⊢ S ⊆ T" tactic="intro h">
                            <AtomNode start="(22, 5)" end="(22, 10)" leading="" trailing=" " val="intro"/>
                            <NullNode start="(22, 11)" end="(22, 12)">
                              <IdentNode start="(22, 11)" end="(22, 12)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(23, 5)" end="(23, 21)" kind="Lean.Parser.Tactic.rwSeq" state_before="case mp&#10;α : Type&#10;S T : Set α&#10;h : 𝓟 S ≤ 𝓟 T&#10;⊢ S ⊆ T" state_after="case mp&#10;α : Type&#10;S T : Set α&#10;h : ∀ x ∈ 𝓟 T, x ∈ 𝓟 S&#10;⊢ S ⊆ T" tactic="rw [le_def] at h">
                            <AtomNode start="(23, 5)" end="(23, 7)" leading="" trailing=" " val="rw"/>
                            <NullNode/>
                            <OtherNode start="(23, 8)" end="(23, 16)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(23, 8)" end="(23, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(23, 9)" end="(23, 15)">
                                <OtherNode start="(23, 9)" end="(23, 15)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(23, 9)" end="(23, 15)" leading="" trailing="" raw_val="le_def" val="le_def" full_name="Filter.le_def" mod_name="Mathlib.Order.Filter.Basic" def_path=".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean" def_start="(308, 9)" def_end="(308, 15)"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(23, 15)" end="(23, 16)" leading="" trailing=" " val="]"/>
                            </OtherNode>
                            <NullNode start="(23, 17)" end="(23, 21)">
                              <OtherNode start="(23, 17)" end="(23, 21)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(23, 17)" end="(23, 19)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(23, 20)" end="(23, 21)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(23, 20)" end="(23, 21)">
                                    <IdentNode start="(23, 20)" end="(23, 21)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                  </NullNode>
                                  <NullNode/>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(24, 5)" end="(24, 46)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case mp&#10;α : Type&#10;S T : Set α&#10;h : ∀ x ∈ 𝓟 T, x ∈ 𝓟 S&#10;⊢ S ⊆ T" state_after="case mp&#10;α : Type&#10;S T : Set α&#10;h : ∀ x ∈ 𝓟 T, x ∈ 𝓟 S&#10;hT : T ∈ 𝓟 T&#10;⊢ S ⊆ T" tactic="have hT : T ∈ 𝓟 T := mem_principal_self T">
                            <AtomNode start="(24, 5)" end="(24, 9)" leading="" trailing=" " val="have"/>
                            <OtherNode start="(24, 10)" end="(24, 46)" kind="Lean.Parser.Term.haveDecl">
                              <OtherNode start="(24, 10)" end="(24, 46)" kind="Lean.Parser.Term.haveIdDecl">
                                <OtherNode start="(24, 10)" end="(24, 12)" kind="Lean.Parser.Term.haveId">
                                  <IdentNode start="(24, 10)" end="(24, 12)" leading="" trailing=" " raw_val="hT" val="hT"/>
                                </OtherNode>
                                <NullNode/>
                                <NullNode start="(24, 13)" end="(24, 22)">
                                  <TermTypespecNode start="(24, 13)" end="(24, 22)">
                                    <AtomNode start="(24, 13)" end="(24, 14)" leading="" trailing=" " val=":"/>
                                    <OtherNode start="(24, 15)" end="(24, 22)" kind="«term_∈_»">
                                      <IdentNode start="(24, 15)" end="(24, 16)" leading="" trailing=" " raw_val="T" val="T"/>
                                      <AtomNode start="(24, 17)" end="(24, 18)" leading="" trailing=" " val="∈"/>
                                      <OtherNode start="(24, 19)" end="(24, 22)" kind="Lean.Parser.Term.app">
                                        <OtherNode start="(24, 19)" end="(24, 20)" kind="Filter.term𝓟">
                                          <AtomNode start="(24, 19)" end="(24, 20)" leading="" trailing=" " val="𝓟"/>
                                        </OtherNode>
                                        <NullNode start="(24, 21)" end="(24, 22)">
                                          <IdentNode start="(24, 21)" end="(24, 22)" leading="" trailing=" " raw_val="T" val="T"/>
                                        </NullNode>
                                      </OtherNode>
                                    </OtherNode>
                                  </TermTypespecNode>
                                </NullNode>
                                <AtomNode start="(24, 23)" end="(24, 25)" leading="" trailing=" " val=":="/>
                                <OtherNode start="(24, 26)" end="(24, 46)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(24, 26)" end="(24, 44)" leading="" trailing=" " raw_val="mem_principal_self" val="mem_principal_self" full_name="Filter.mem_principal_self" mod_name="Mathlib.Order.Filter.Basic" def_path=".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean" def_start="(277, 9)" def_end="(277, 27)"/>
                                  <NullNode start="(24, 45)" end="(24, 46)">
                                    <IdentNode start="(24, 45)" end="(24, 46)" leading="" trailing="&#10;    " raw_val="T" val="T"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(25, 5)" end="(25, 22)" kind="Lean.Parser.Tactic.specialize" state_before="case mp&#10;α : Type&#10;S T : Set α&#10;h : ∀ x ∈ 𝓟 T, x ∈ 𝓟 S&#10;hT : T ∈ 𝓟 T&#10;⊢ S ⊆ T" state_after="case mp&#10;α : Type&#10;S T : Set α&#10;hT : T ∈ 𝓟 T&#10;h : T ∈ 𝓟 S&#10;⊢ S ⊆ T" tactic="specialize h T hT">
                            <AtomNode start="(25, 5)" end="(25, 15)" leading="" trailing=" " val="specialize"/>
                            <OtherNode start="(25, 16)" end="(25, 22)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(25, 16)" end="(25, 17)" leading="" trailing=" " raw_val="h" val="h"/>
                              <NullNode start="(25, 18)" end="(25, 22)">
                                <IdentNode start="(25, 18)" end="(25, 19)" leading="" trailing=" " raw_val="T" val="T"/>
                                <IdentNode start="(25, 20)" end="(25, 22)" leading="" trailing="&#10;    " raw_val="hT" val="hT"/>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(26, 5)" end="(26, 29)" kind="Lean.Parser.Tactic.tacticRwa__" state_before="case mp&#10;α : Type&#10;S T : Set α&#10;hT : T ∈ 𝓟 T&#10;h : T ∈ 𝓟 S&#10;⊢ S ⊆ T" state_after="no goals" tactic="rwa [mem_principal] at h">
                            <AtomNode start="(26, 5)" end="(26, 8)" leading="" trailing=" " val="rwa"/>
                            <OtherNode start="(26, 9)" end="(26, 24)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(26, 9)" end="(26, 10)" leading="" trailing="" val="["/>
                              <NullNode start="(26, 10)" end="(26, 23)">
                                <OtherNode start="(26, 10)" end="(26, 23)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(26, 10)" end="(26, 23)" leading="" trailing="" raw_val="mem_principal" val="mem_principal" full_name="Filter.mem_principal" mod_name="Mathlib.Order.Filter.Basic" def_path=".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean" def_start="(275, 17)" def_end="(275, 30)"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(26, 23)" end="(26, 24)" leading="" trailing=" " val="]"/>
                            </OtherNode>
                            <NullNode start="(26, 25)" end="(26, 29)">
                              <OtherNode start="(26, 25)" end="(26, 29)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(26, 25)" end="(26, 27)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(26, 28)" end="(26, 29)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(26, 28)" end="(26, 29)">
                                    <IdentNode start="(26, 28)" end="(26, 29)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                                  </NullNode>
                                  <NullNode/>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(27, 3)" end="(31, 30)" kind="Lean.cdot" state_before="case mpr&#10;α : Type&#10;S T : Set α&#10;⊢ S ⊆ T → 𝓟 S ≤ 𝓟 T" state_after="no goals" tactic="· intro hST&#10;  rw [le_def]&#10;  intro X hX&#10;  rw [mem_principal] at hX ⊢&#10;  exact Subset.trans hST hX">
                    <OtherNode start="(27, 3)" end="(27, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(27, 3)" end="(27, 4)" kind="patternIgnore">
                        <OtherNode start="(27, 3)" end="(27, 4)" kind="token.«· »">
                          <AtomNode start="(27, 3)" end="(27, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(27, 5)" end="(31, 30)">
                      <TacticTacticseq1IndentedNode start="(27, 5)" end="(31, 30)">
                        <NullNode start="(27, 5)" end="(31, 30)">
                          <OtherNode start="(27, 5)" end="(27, 14)" kind="Lean.Parser.Tactic.intro" state_before="case mpr&#10;α : Type&#10;S T : Set α&#10;⊢ S ⊆ T → 𝓟 S ≤ 𝓟 T" state_after="case mpr&#10;α : Type&#10;S T : Set α&#10;hST : S ⊆ T&#10;⊢ 𝓟 S ≤ 𝓟 T" tactic="intro hST">
                            <AtomNode start="(27, 5)" end="(27, 10)" leading="" trailing=" " val="intro"/>
                            <NullNode start="(27, 11)" end="(27, 14)">
                              <IdentNode start="(27, 11)" end="(27, 14)" leading="" trailing="&#10;    " raw_val="hST" val="hST"/>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(28, 5)" end="(28, 16)" kind="Lean.Parser.Tactic.rwSeq" state_before="case mpr&#10;α : Type&#10;S T : Set α&#10;hST : S ⊆ T&#10;⊢ 𝓟 S ≤ 𝓟 T" state_after="case mpr&#10;α : Type&#10;S T : Set α&#10;hST : S ⊆ T&#10;⊢ ∀ x ∈ 𝓟 T, x ∈ 𝓟 S" tactic="rw [le_def]">
                            <AtomNode start="(28, 5)" end="(28, 7)" leading="" trailing=" " val="rw"/>
                            <NullNode/>
                            <OtherNode start="(28, 8)" end="(28, 16)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(28, 8)" end="(28, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(28, 9)" end="(28, 15)">
                                <OtherNode start="(28, 9)" end="(28, 15)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(28, 9)" end="(28, 15)" leading="" trailing="" raw_val="le_def" val="le_def" full_name="Filter.le_def" mod_name="Mathlib.Order.Filter.Basic" def_path=".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean" def_start="(308, 9)" def_end="(308, 15)"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(28, 15)" end="(28, 16)" leading="" trailing="&#10;    " val="]"/>
                            </OtherNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(29, 5)" end="(29, 15)" kind="Lean.Parser.Tactic.intro" state_before="case mpr&#10;α : Type&#10;S T : Set α&#10;hST : S ⊆ T&#10;⊢ ∀ x ∈ 𝓟 T, x ∈ 𝓟 S" state_after="case mpr&#10;α : Type&#10;S T : Set α&#10;hST : S ⊆ T&#10;X : Set α&#10;hX : X ∈ 𝓟 T&#10;⊢ X ∈ 𝓟 S" tactic="intro X hX">
                            <AtomNode start="(29, 5)" end="(29, 10)" leading="" trailing=" " val="intro"/>
                            <NullNode start="(29, 11)" end="(29, 15)">
                              <IdentNode start="(29, 11)" end="(29, 12)" leading="" trailing=" " raw_val="X" val="X"/>
                              <IdentNode start="(29, 13)" end="(29, 15)" leading="" trailing="&#10;    " raw_val="hX" val="hX"/>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(30, 5)" end="(30, 31)" kind="Lean.Parser.Tactic.rwSeq" state_before="case mpr&#10;α : Type&#10;S T : Set α&#10;hST : S ⊆ T&#10;X : Set α&#10;hX : X ∈ 𝓟 T&#10;⊢ X ∈ 𝓟 S" state_after="case mpr&#10;α : Type&#10;S T : Set α&#10;hST : S ⊆ T&#10;X : Set α&#10;hX : T ⊆ X&#10;⊢ S ⊆ X" tactic="rw [mem_principal] at hX ⊢">
                            <AtomNode start="(30, 5)" end="(30, 7)" leading="" trailing=" " val="rw"/>
                            <NullNode/>
                            <OtherNode start="(30, 8)" end="(30, 23)" kind="Lean.Parser.Tactic.rwRuleSeq">
                              <AtomNode start="(30, 8)" end="(30, 9)" leading="" trailing="" val="["/>
                              <NullNode start="(30, 9)" end="(30, 22)">
                                <OtherNode start="(30, 9)" end="(30, 22)" kind="Lean.Parser.Tactic.rwRule">
                                  <NullNode/>
                                  <IdentNode start="(30, 9)" end="(30, 22)" leading="" trailing="" raw_val="mem_principal" val="mem_principal" full_name="Filter.mem_principal" mod_name="Mathlib.Order.Filter.Basic" def_path=".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean" def_start="(275, 17)" def_end="(275, 30)"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(30, 22)" end="(30, 23)" leading="" trailing=" " val="]"/>
                            </OtherNode>
                            <NullNode start="(30, 24)" end="(30, 31)">
                              <OtherNode start="(30, 24)" end="(30, 31)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(30, 24)" end="(30, 26)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(30, 27)" end="(30, 31)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(30, 27)" end="(30, 29)">
                                    <IdentNode start="(30, 27)" end="(30, 29)" leading="" trailing=" " raw_val="hX" val="hX"/>
                                  </NullNode>
                                  <NullNode start="(30, 30)" end="(30, 31)">
                                    <OtherNode start="(30, 30)" end="(30, 31)" kind="patternIgnore">
                                      <OtherNode start="(30, 30)" end="(30, 31)" kind="token.«⊢»">
                                        <AtomNode start="(30, 30)" end="(30, 31)" leading="" trailing="&#10;    " val="⊢"/>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(31, 5)" end="(31, 30)" kind="Lean.Parser.Tactic.exact" state_before="case mpr&#10;α : Type&#10;S T : Set α&#10;hST : S ⊆ T&#10;X : Set α&#10;hX : T ⊆ X&#10;⊢ S ⊆ X" state_after="no goals" tactic="exact Subset.trans hST hX">
                            <AtomNode start="(31, 5)" end="(31, 10)" leading="" trailing=" " val="exact"/>
                            <OtherNode start="(31, 11)" end="(31, 30)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(31, 11)" end="(31, 23)" leading="" trailing=" " raw_val="Subset.trans" val="Subset.trans" full_name="Set.Subset.trans" mod_name="Mathlib.Data.Set.Basic" def_path=".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean" def_start="(298, 9)" def_end="(298, 21)"/>
                              <NullNode start="(31, 24)" end="(31, 30)">
                                <IdentNode start="(31, 24)" end="(31, 27)" leading="" trailing=" " raw_val="hST" val="hST"/>
                                <IdentNode start="(31, 28)" end="(31, 30)" leading="" trailing="&#10;&#10;" raw_val="hX" val="hX"/>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(33, 1)" end="(37, 13)" name="test2" full_name="test2">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(33, 1)" end="(37, 13)" name="test2" full_name="test2" _is_private_decl="False">
        <AtomNode start="(33, 1)" end="(33, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(33, 9)" end="(33, 14)">
          <IdentNode start="(33, 9)" end="(33, 14)" leading="" trailing=" " raw_val="test2" val="test2"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(33, 15)" end="(33, 42)">
          <NullNode/>
          <TermTypespecNode start="(33, 15)" end="(33, 42)">
            <AtomNode start="(33, 15)" end="(33, 16)" leading="" trailing=" " val=":"/>
            <OtherNode start="(33, 17)" end="(33, 42)" kind="Lean.Parser.Term.arrow">
              <OtherNode start="(33, 17)" end="(33, 24)" kind="Lean.Parser.Term.paren">
                <AtomNode start="(33, 17)" end="(33, 18)" leading="" trailing="" val="("/>
                <OtherNode start="(33, 18)" end="(33, 23)" kind="«term_∧_»">
                  <IdentNode start="(33, 18)" end="(33, 19)" leading="" trailing=" " raw_val="p" val="p"/>
                  <AtomNode start="(33, 20)" end="(33, 21)" leading="" trailing=" " val="∧"/>
                  <IdentNode start="(33, 22)" end="(33, 23)" leading="" trailing="" raw_val="q" val="q"/>
                </OtherNode>
                <AtomNode start="(33, 23)" end="(33, 24)" leading="" trailing=" " val=")"/>
              </OtherNode>
              <AtomNode start="(33, 25)" end="(33, 26)" leading="" trailing=" " val="→"/>
              <OtherNode start="(33, 27)" end="(33, 42)" kind="Lean.Parser.Term.arrow">
                <OtherNode start="(33, 27)" end="(33, 38)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(33, 27)" end="(33, 28)" leading="" trailing="" val="("/>
                  <OtherNode start="(33, 28)" end="(33, 37)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(33, 28)" end="(33, 29)" leading="" trailing=" " raw_val="p" val="p"/>
                    <AtomNode start="(33, 30)" end="(33, 31)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(33, 32)" end="(33, 37)" kind="Lean.Parser.Term.arrow">
                      <IdentNode start="(33, 32)" end="(33, 33)" leading="" trailing=" " raw_val="q" val="q"/>
                      <AtomNode start="(33, 34)" end="(33, 35)" leading="" trailing=" " val="→"/>
                      <IdentNode start="(33, 36)" end="(33, 37)" leading="" trailing="" raw_val="r" val="r"/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(33, 37)" end="(33, 38)" leading="" trailing=" " val=")"/>
                </OtherNode>
                <AtomNode start="(33, 39)" end="(33, 40)" leading="" trailing=" " val="→"/>
                <IdentNode start="(33, 41)" end="(33, 42)" leading="" trailing=" " raw_val="r" val="r"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(33, 43)" end="(37, 13)">
          <AtomNode start="(33, 43)" end="(33, 45)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(33, 46)" end="(37, 13)">
            <AtomNode start="(33, 46)" end="(33, 48)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(34, 3)" end="(37, 13)">
              <TacticTacticseq1IndentedNode start="(34, 3)" end="(37, 13)">
                <NullNode start="(34, 3)" end="(37, 13)">
                  <OtherNode start="(34, 3)" end="(34, 14)" kind="Lean.Parser.Tactic.intro" state_before="p q r : Prop&#10;⊢ p ∧ q → (p → q → r) → r" state_after="p q r : Prop&#10;h1 : p ∧ q&#10;h2 : p → q → r&#10;⊢ r" tactic="intro h1 h2">
                    <AtomNode start="(34, 3)" end="(34, 8)" leading="" trailing=" " val="intro"/>
                    <NullNode start="(34, 9)" end="(34, 14)">
                      <IdentNode start="(34, 9)" end="(34, 11)" leading="" trailing=" " raw_val="h1" val="h1"/>
                      <IdentNode start="(34, 12)" end="(34, 14)" leading="" trailing="&#10;  " raw_val="h2" val="h2"/>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(35, 3)" end="(35, 11)" kind="Lean.Parser.Tactic.apply" state_before="p q r : Prop&#10;h1 : p ∧ q&#10;h2 : p → q → r&#10;⊢ r" state_after="case a&#10;p q r : Prop&#10;h1 : p ∧ q&#10;h2 : p → q → r&#10;⊢ p&#10;&#10;case a&#10;p q r : Prop&#10;h1 : p ∧ q&#10;h2 : p → q → r&#10;⊢ q" tactic="apply h2">
                    <AtomNode start="(35, 3)" end="(35, 8)" leading="" trailing=" " val="apply"/>
                    <IdentNode start="(35, 9)" end="(35, 11)" leading="" trailing="&#10;  " raw_val="h2" val="h2"/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(36, 3)" end="(36, 13)" kind="Lean.Parser.Tactic.exact" state_before="case a&#10;p q r : Prop&#10;h1 : p ∧ q&#10;h2 : p → q → r&#10;⊢ p&#10;&#10;case a&#10;p q r : Prop&#10;h1 : p ∧ q&#10;h2 : p → q → r&#10;⊢ q" state_after="case a&#10;p q r : Prop&#10;h1 : p ∧ q&#10;h2 : p → q → r&#10;⊢ q" tactic="exact h1.1">
                    <AtomNode start="(36, 3)" end="(36, 8)" leading="" trailing=" " val="exact"/>
                    <OtherNode start="(36, 9)" end="(36, 13)" kind="Lean.Parser.Term.proj">
                      <IdentNode start="(36, 9)" end="(36, 11)" leading="" trailing="" raw_val="h1" val="h1"/>
                      <AtomNode start="(36, 11)" end="(36, 12)" leading="" trailing="" val="."/>
                      <OtherNode start="(36, 12)" end="(36, 13)" kind="fieldIdx">
                        <AtomNode start="(36, 12)" end="(36, 13)" leading="" trailing="&#10;  " val="1"/>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(37, 3)" end="(37, 13)" kind="Lean.Parser.Tactic.exact" state_before="case a&#10;p q r : Prop&#10;h1 : p ∧ q&#10;h2 : p → q → r&#10;⊢ q" state_after="no goals" tactic="exact h1.2">
                    <AtomNode start="(37, 3)" end="(37, 8)" leading="" trailing=" " val="exact"/>
                    <OtherNode start="(37, 9)" end="(37, 13)" kind="Lean.Parser.Term.proj">
                      <IdentNode start="(37, 9)" end="(37, 11)" leading="" trailing="" raw_val="h1" val="h1"/>
                      <AtomNode start="(37, 11)" end="(37, 12)" leading="" trailing="" val="."/>
                      <OtherNode start="(37, 12)" end="(37, 13)" kind="fieldIdx">
                        <AtomNode start="(37, 12)" end="(37, 13)" leading="" trailing="&#10;&#10;" val="2"/>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(39, 1)" end="(43, 13)" name="sorry_test" full_name="sorry_test">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(39, 1)" end="(43, 13)" name="sorry_test" full_name="sorry_test" _is_private_decl="False">
        <AtomNode start="(39, 1)" end="(39, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(39, 9)" end="(39, 19)">
          <IdentNode start="(39, 9)" end="(39, 19)" leading="" trailing=" " raw_val="sorry_test" val="sorry_test"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(39, 20)" end="(39, 47)">
          <NullNode/>
          <TermTypespecNode start="(39, 20)" end="(39, 47)">
            <AtomNode start="(39, 20)" end="(39, 21)" leading="" trailing=" " val=":"/>
            <OtherNode start="(39, 22)" end="(39, 47)" kind="Lean.Parser.Term.arrow">
              <OtherNode start="(39, 22)" end="(39, 29)" kind="Lean.Parser.Term.paren">
                <AtomNode start="(39, 22)" end="(39, 23)" leading="" trailing="" val="("/>
                <OtherNode start="(39, 23)" end="(39, 28)" kind="«term_∧_»">
                  <IdentNode start="(39, 23)" end="(39, 24)" leading="" trailing=" " raw_val="p" val="p"/>
                  <AtomNode start="(39, 25)" end="(39, 26)" leading="" trailing=" " val="∧"/>
                  <IdentNode start="(39, 27)" end="(39, 28)" leading="" trailing="" raw_val="q" val="q"/>
                </OtherNode>
                <AtomNode start="(39, 28)" end="(39, 29)" leading="" trailing=" " val=")"/>
              </OtherNode>
              <AtomNode start="(39, 30)" end="(39, 31)" leading="" trailing=" " val="→"/>
              <OtherNode start="(39, 32)" end="(39, 47)" kind="Lean.Parser.Term.arrow">
                <OtherNode start="(39, 32)" end="(39, 43)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(39, 32)" end="(39, 33)" leading="" trailing="" val="("/>
                  <OtherNode start="(39, 33)" end="(39, 42)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(39, 33)" end="(39, 34)" leading="" trailing=" " raw_val="p" val="p"/>
                    <AtomNode start="(39, 35)" end="(39, 36)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(39, 37)" end="(39, 42)" kind="Lean.Parser.Term.arrow">
                      <IdentNode start="(39, 37)" end="(39, 38)" leading="" trailing=" " raw_val="q" val="q"/>
                      <AtomNode start="(39, 39)" end="(39, 40)" leading="" trailing=" " val="→"/>
                      <IdentNode start="(39, 41)" end="(39, 42)" leading="" trailing="" raw_val="r" val="r"/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(39, 42)" end="(39, 43)" leading="" trailing=" " val=")"/>
                </OtherNode>
                <AtomNode start="(39, 44)" end="(39, 45)" leading="" trailing=" " val="→"/>
                <IdentNode start="(39, 46)" end="(39, 47)" leading="" trailing=" " raw_val="r" val="r"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(39, 48)" end="(43, 13)">
          <AtomNode start="(39, 48)" end="(39, 50)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(39, 51)" end="(43, 13)">
            <AtomNode start="(39, 51)" end="(39, 53)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(40, 3)" end="(43, 13)">
              <TacticTacticseq1IndentedNode start="(40, 3)" end="(43, 13)">
                <NullNode start="(40, 3)" end="(43, 13)">
                  <OtherNode start="(40, 3)" end="(40, 14)" kind="Lean.Parser.Tactic.intro" state_before="p q r : Prop&#10;⊢ p ∧ q → (p → q → r) → r" state_after="p q r : Prop&#10;h1 : p ∧ q&#10;h2 : p → q → r&#10;⊢ r" tactic="intro h1 h2">
                    <AtomNode start="(40, 3)" end="(40, 8)" leading="" trailing=" " val="intro"/>
                    <NullNode start="(40, 9)" end="(40, 14)">
                      <IdentNode start="(40, 9)" end="(40, 11)" leading="" trailing=" " raw_val="h1" val="h1"/>
                      <IdentNode start="(40, 12)" end="(40, 14)" leading="" trailing="&#10;  " raw_val="h2" val="h2"/>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(41, 3)" end="(41, 11)" kind="Lean.Parser.Tactic.apply" state_before="p q r : Prop&#10;h1 : p ∧ q&#10;h2 : p → q → r&#10;⊢ r" state_after="case a&#10;p q r : Prop&#10;h1 : p ∧ q&#10;h2 : p → q → r&#10;⊢ p&#10;&#10;case a&#10;p q r : Prop&#10;h1 : p ∧ q&#10;h2 : p → q → r&#10;⊢ q" tactic="apply h2">
                    <AtomNode start="(41, 3)" end="(41, 8)" leading="" trailing=" " val="apply"/>
                    <IdentNode start="(41, 9)" end="(41, 11)" leading="" trailing="&#10;  " raw_val="h2" val="h2"/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(42, 3)" end="(42, 8)" kind="Lean.Parser.Tactic.tacticSorry" state_before="case a&#10;p q r : Prop&#10;h1 : p ∧ q&#10;h2 : p → q → r&#10;⊢ p&#10;&#10;case a&#10;p q r : Prop&#10;h1 : p ∧ q&#10;h2 : p → q → r&#10;⊢ q" state_after="case a&#10;p q r : Prop&#10;h1 : p ∧ q&#10;h2 : p → q → r&#10;⊢ q" tactic="sorry">
                    <AtomNode start="(42, 3)" end="(42, 8)" leading="" trailing="&#10;  " val="sorry"/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(43, 3)" end="(43, 13)" kind="Lean.Parser.Tactic.exact" state_before="case a&#10;p q r : Prop&#10;h1 : p ∧ q&#10;h2 : p → q → r&#10;⊢ q" state_after="no goals" tactic="exact h1.2">
                    <AtomNode start="(43, 3)" end="(43, 8)" leading="" trailing=" " val="exact"/>
                    <OtherNode start="(43, 9)" end="(43, 13)" kind="Lean.Parser.Term.proj">
                      <IdentNode start="(43, 9)" end="(43, 11)" leading="" trailing="" raw_val="h1" val="h1"/>
                      <AtomNode start="(43, 11)" end="(43, 12)" leading="" trailing="" val="."/>
                      <OtherNode start="(43, 12)" end="(43, 13)" kind="fieldIdx">
                        <AtomNode start="(43, 12)" end="(43, 13)" leading="" trailing="&#10;" val="2"/>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
  </FileNode>
  <Comments>
    <Comment start="(2, 1)" end="(3, 1)" text="-- imports all the Lean tactics&#10;"/>
  </Comments>
</TracedFile>
